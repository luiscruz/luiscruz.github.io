---
layout: post
author: Lu√≠s Cruz
title: "The role of education in Green Software and how to get started. Branch."
# image: "img/blog/2021-branch/og_image.png"
show_image: False
mermaid: False
equation: False
draft: True
invisible: True
summary: "Education plays an important role in leading the upcoming green digital transition. Soon, being green-literate will be quintessential to the development of software systems at any scale. Join the group of innovators of this green transition and get started in measuring the energy consumption of software form your computer."
---

<span class="first-letter">D</span>eveloping green software is the new tech skill that is becoming more and more important. The ambition to achieve climate neutrality is being set by many public- and private-sector leaders and it is clear that the tech sector has an important role to play here. Soon, every tech company will have to embrace the green digital transition and ensure that energy-efficient software is an essential part of this transition.

But before we are able to normalise green software, we need everyone to be able to speak "greenish"(note: *should I change it to green-literate*?). We will never get there if our engineers, scientists, designers, marketeers, and so on are not knowledgeable about the foundations of energy and carbon efficiency. (Note: *I'm not happy with these sentences yet. I like the idea, though*) If everyone is able to measure and interpret energy data from their software, building energy-efficiency will be inherently considered in software development activities. Once again, education is key.

Nevertheless, for a long time, energy efficiency and sustainability were never really part of the curriculum of computer science programmes at universities. The only thing that could somehow resemble energy efficiency is performance: students usually show a natural satisfaction making their code execute in the least possible time. Unfortunately, this enthusiasm of students about making the code more time-efficient is not observed for energy efficiency. Although students are usually interested in learning about sustainability of software engineering, there is a steep learning curve that needs to be overcome. As opposed to analysing and measuring time, which is simple and accessible, energy data is everything but that.

In that sense, we need to give it a little push before we can have everyone fluent in "greenish".
Hence, universities are pioneering new courses on sustainable software engineering. That's the case of Delft University of Technology, who will its first course on software sustainability already starting in this academic year.[^SustainableSE]

But of course, the change cannot only happen with the new generation of tech developers. We need to embrace the green digital transformation at all levels.
Tech professionals are already used to constantly re-educating themselves on the latest new tool or technique.
Unfortunately, there is not a lot of content when it comes to the development of energy-efficient software applications. We need more tutorials, discussions, data, tools, and ideas!

As always, we need to start small. One of the first things that we, green software enthusiasts, need to learn is how to measure the energy consumption of software. This is a twofold problem. **First,** there is a myriad of factors that affect energy consumption, making it difficult to compute the exact energy consumption. This is especially worrisome when you are comparing different versions of a given software ‚Äì you need to make sure that you are comparing the energy consumption entailed by your software and not by anything else running in your computer. **Second,** there are many tools out there, but there is no one-size-fits-all solution. Some tools only work with specific operative systems, hardware, etc. 

But don't worry: this article gets you covered. We will see **how to prepare our machine to collect reliable energy measurements** and **how to use a tool that actually collects energy data** from most ordinary personal computers.

Let's start with the list of things you need to fix before starting measuring:

1. **Stop all unnecessary tasks üßòüèæ‚Äç‚ôÄÔ∏è**. Before measuring, all other applications should be closed, notifications should be off, only required hardware should be connected and, if you don't need internet for the measurement, your computer should be offline.  
2. **Freeze your settings ü•∂**. Sometimes, you cannot completely stop all the things that are unrelated to your software. Hence, make sure you freeze all the settings ‚Äì for example, the brightness of your screen should be the same in all the measurements.
3. **Warm up your setup üì∂**. Energy consumption is highly affected by the temperature of your hardware. Hence, always do a small warm-up before running experiments.
4. **Sleep between measurements ‚è∏**. After the execution of a given program, your computer will still incur into residual energy consumption that stemmed from its execution. This is commonly named as *tail energy consumption*. To prevent the tail energy consumption from affecting the results of a subsequent execution, do a short pause between measurements. 
5. **Control room temperature üå°**. The temperature affects energy consumption. Hence, make sure you have the same room temperature for all the measurements.
6. **Repeat measurements a few times üîÅ**. Despite all efforts to avoid errors, energy measurement are still prone to random variations. This means that it could happen that a new version of your software is perceived as more or less energy efficient just because of these random variations in the energy consumption. The only way we can fix that is by repeating measurements until results look consistent. This is illustrated in the animation below: the first measurement indicates that version `B` is less efficient than `A`; after repeating the measurements, we see that version `B` spends roughly less 20 joules than `A`. 

![Violin plots](/img/blog/2021-branch/repeat.mp4){: class="center-block" width="500px" }
<p class="caption" markdown="span">Plot of the distribution of energy consumption for versions `A` and `B`. In each iteration we add another round of measurements (depicted with the new blue circles). When we reach iteration 30, it is clear that version B is more energy efficient. On average version `A` uses 100 joules and version `B` uses 80 joules, yielding a 20% improvement. [View source][Plots source].</p>

{:start="7"}

7. **Create automated executions ü§ñ**. If we want to repeat measurements, they should be repeatable. No better way to do this than by automating executions. This is typically done with common software testing tools. 

8. **Shuffle measurements üîÄ**. Instead of executing all the measurements for a given version and then all the measurements for another version, it is recommended to randomly shuffle the executions. This way, we prevent any unexpected (yet unnoticeable) measurement error from affecting only one of the versions being tested.

Keep in mind, though, that **these guidelines should not discourage you from measuring energy consumption**. My advice is that you **start simple** ‚Äì no automation, no repetitions, etc. ‚Äì only a simple first result to give you some intuition. That is more than enough to start discussing the energy consumption of your software and to get your colleagues into it.

Nevertheless, if you really want your team to use energy results consistently, you will eventually need to cover all these guidelines.
Failing to adopt them will lead to something that software engineers often call **flakiness**: when two executions of the same test produce different results. The problem of flaky tests is that developers will stop worrying when tests fail ‚Äì making tests useless. And we want the results of energy tests to be taken seriously.

Now that we know all the basics about measuring energy consumption, there is one last thing that needs to be mastered: the collection of energy consumption data. In the old days, one could only measure energy consumption using special hardware with physical power sensors. Today, we have several tools that provide reliable power estimations. That's the case of [Intel Power Gadget], which is the easiest and most accessible energy measurement tool I have come across. It provides a handy graphical interface, and anyone can use this tool with only little tech skills.

Here's how to use it:

1. **Install it** üì•. via the official website:<br/> [https://software.intel.com/content/www/us/en/develop/articles/intel-power-gadget.html][IntelPowerGadget]

2. **Open it** üìÇ. The interface shows a few plots with `CPU utilisation (%)`, `Frequency (GHz)`, `Temperature (¬∫C)`, and `Power (W)`.

![Intel Power Gadget Interface](/img/blog/2021-07-20/intel-power-gadget.png){: class="center-block" width="400px" }

{:start="3"}
3. **Start collecting** üîã. You simply have to click on the menu `Logging > Log to File` to start measuring (and once again stop it).

![Intel Power Gadget Start Menu](/img/blog/2021-07-20/intel-power-gadget-menu.png){: class="center-block" width="400px" }

{:start="4"}
4. **Check results** üìä. The power data will be collected and stored in a `CSV` file under your Documents folder (default behaviour). I have run a small test and, in my case, it was stored in `~/Documents/PwrData_2021-2-19_17-16-10.csv`.

When we open the CSV file ‚Äì using, for example, Excel ‚Äì you find several columns. Some are straightforward ‚Äì e.g., `System Time`, `Elapsed Time (sec)`, `Processor Power_0(Watt)` ‚Äì while others tend to be more complex ‚Äì e.g., `RDTSC` and `GT Requsted Frequency(MHz)`.

Let's not worry too much about it. If you scroll all the way down to the bottom of the file, there is a summary table with a few important attributes:

- **Total Elapsed Time (sec)**. The total time in seconds in which power data was being collected.
- **Cumulative Package Energy_0 (Joules)**. The total energy consumption of the processor.
- **Cumulative DRAM Energy_0 (Joules)**. The total energy consumption of the volatile memory.

![Intel Power Gadget Data](/img/blog/2021-07-20/intel-power-gadget-data.png){: class="center-block" width="400px" }


**And that's it**! You have made your first energy measurement! Now, go ahead and start measuring the energy consumption of your favourite apps. For example, what is more energy-efficient: a 10-minute call over zoom or the same call over Microsoft Teams? Browsing the Web using Chrome or Firefox?

Keep in mind, however, that the main strength of the [Intel Power Gadget] is also its main weakness: the graphical interface is really easy to use but it is not so simple if you want to automate executions. Command-line interfaces are more suitable for automation. There are a few alternatives out there ‚Äì check [this article][energy tools] on energy tools if you want to try a different energy measurement tool.

Finally, unfortunately, we can only measure the energy being used by our computers. Much more goes into the energy footprint stemmed from our activity in front of the screen. Cloud servers, internet providers, and so on, they all work so well that we have no idea what exactly happens beyond our desks ‚Äì including the total energy being used. Yet, this is the first step to get everyone involved and have all the techies talking about energy efficiency. There is only a positive effect if we all start measuring energy consumption: tools will have more users, improve usability, improve compatibility with more hardware, etc. The more we democratise energy measurements, the more green-literate engineers we will have working in the next generation of software, AI applications, cloud systems, datacentres, and so on. **Eventually, green software development will be the only software development we know.**

[^SustainableSE]: Syllabus and materials of the course Sustainable Software Engineering at the Delft University of Technology: [https://luiscruz.github.io/course_sustainableSE/](https://luiscruz.github.io/course_sustainableSE/)

[Plots source]: https://colab.research.google.com/drive/1DmFuBwhs9wI4_6zaaUh5B1rTiVt-hNt9?usp=sharing
[IntelPowerGadget]: https://software.intel.com/content/www/us/en/develop/articles/intel-power-gadget.html
[energy tools]: https://luiscruz.github.io/2021/07/20/measuring-energy.html


Questions to Michelle:

- tone! is it okay?
- links to external articles? should I have a list of resources at the bottom?
- flow! I'm going from education to practical tools. Is it flowing?
- publicity to the course of TU Delft. Is it too much?

